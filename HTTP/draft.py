"""
    Простыми словами:
    HTTP протокол - это набор правил по передаче данных между приложениями(клиентом и сервером).
    Сначала — в виде гипертекстовых документов в формате HTML, теперь в поизвольном виде.

    Это договоренность о том, как отсылать, принимать, понимать информацию и как на нее реагировать.

    Чтобы разные приложения в сети могли общаться друг с другом, понимать друг друга, им нужны общие соглашения.
    Если их не будет, то каждое приложение будет придерживаться своих правил и не сможет понимать другие приложения.

    Основные понятия описанные в протоколе HTTP касаются того, как должны быть сформированы сообщения, передаваемые между
    приложениями, что означают параметры этих сообщений, как реагировать на те или иные параметры, а также касаются
    использования механизмов управления соединениями.

============================================================================================================================

    https://www.youtube.com/watch?v=C_QZtajkDf0

    ==================== - Означает проверить инфу, понять и объяснить более лаконично.

    HTTP пакет состоит из трёх частей:
    https://selectel.ru/blog/http-request/
    1 Стартовая строка

        В стартовой строке ЗАПРОСА указываются метод запроса, URL, версия
        протокола.
        ====================
        Host надо указывать для того, чтобы сервер знал к какому хосту этот
        запрос адресован. Чтобы не произошло путаницы на случай, если на одном
        сервере крутится несколько хостов.
        ====================
        Аргументы GET запроса передаются в URL
        URL состоит из URL, по которому мы обращаемся внутри сервера и
        параметров
        Пример:
        GET /solrsearch/select?q=guice&rows=22&wt=json HTTP/1.1
        Host: search.maven.org
        URL - /solrsearch/select
        ? - разделяет URL и параметры
        Параметры - q=guice&rows=22&wt=json
        & - разделяет один параметр от другого
        ====================

        Стартовая строка отделяется от заголовков двумя переводами строки \n\n

        В стартовой строке ОТВЕТА указывается версия протокола и код состояния
        обработки запроса.

        Кодов состояния 5 типов:
        1хх - Информирование о процессе передачи запроса
        2хх - Информирование об успешной передаче
        3хх - Информирование о перенаправлении
        4хх - Ошибки клиента, означающие, что ты либо ищешь то чего нет,
        либо делаешь это не правильно, либо тебе сюда нельзя
        5хх - Ошибки, означающие, что серверу сейчас плохо

    2 Заголовок

        Заголовки - это параметры, которые определяют запрос или описывают
        тело сообщения. Напрмер это может быть информация о браузере, языки,
        авторизация и т.д.

        Заголовки от тела отделяются двумя переводами строки \n\n

        Connection: close - этот заголовок означает, что после того как сервер
        ответит, он может закрыть соединение.
        Сервер после ответа может не закрывать соединение, чтобы более
        качественно утилизировать это соединение и отдать допустим несколько
        запросов через один connection. Это получается гораздо быстрее и
        экономит ресурсы машины.
        ====================

        Content-type: application/json - указываем то, что будем отправлять
        нашему серверу
        ====================
        Content-length: 14 - чтобы сервер ожидал ровно столько данных в теле
        запроса, сколько мы указали
        Двойной перевод строки как спусковой крючок для сервера.
        После него происходит обработка запроса сервером.
        Сервер ожидает двойного перевода строки и сразу же после этого начинает
        отвечать.
        Но если мы уазали Content-length, то сервер перед обработкой еще
        ожидает от нас указанное кол-во символов в запросе
        Таким образом мы можем определить, что сервер после двойного перевода
        строки, не должен начинать свой ответ, а должен дождаться указанное
        кол-во символов
        Мы разобрались с тем как передаются body(тело запроса)
        ====================

    3 Тело сообщения

        Тело - это данные, которые мы либо передаем в запросе, например текст
        комментария, либо ответ, который мы получаем от сервера, например
        страничка с видео.

    Все эти данные протокол HTTP передает в открытом виде как обычный текст.
    Поэтому, если где то на пути до сервера злоумышленник перехватит эти
    сообщения, то сможет легко все прочитать

    Пример GET запроса:
        GET / HTTP/1.1
        Host: httpbin.org\n
        \n

    Пример ответа:
        HTTP/1.1 200 OK
        Date: Web, 29 Apr 2020 06:28:07 GMT
        Content-Type: text/html; charset=utf-8
        Content-Length: 9593
        Connection: keep-alive
        Server: gunicorn/19.9.0
        Access-Control-Allow-Origin: *
        Access-Control-Allow-Credentials: true\n
        \n
        <!DOCTYPE html>
        <html lang="en">

        <head>...


    Как же у нас летают POST аргументы, которые являются
    допустим элементами формы или когда мы отправляем файлы.
    Здесь достаточно просто. Body у нас это текст и нам всего лишь
    нужно указать что весь контент, который мы отправляем это форма,
    всего лишь какой то формат
    Content-Type: application/x-www-form-urlencoded
    ====================

    Пример:
    POST / contact_form.php HTTP/1.1
    Host: developer.mozzila.org
    Content-Length: 64
    Content-Type: application/x-www-form-urlencoded\n
    \n
    name=Joe%20User&request=Send%20me%20one%20of%20your%20catalogue

    У нас здесь в теле такие же пары как и в GET запросе:
    Аргумент - name
    равно - =
    Какое то значение - Joe%20User
    Разделение пар - &

    Если мы в контент тайп укажем формат csv, то в тело мы сможем передавать
    данные разделенные запятыми и т.д.

    То есть Content-Type нужен для того, чтобы тот фреймворк, который на
    стороне сервера обрабатывает входящие запросы, сразу знал в какую форму
    парсить значения из тела. Какой парсер для этого подключить.
    ====================


    Что же касается форм в которых мы отправляем файлы?
    Формы, которые отправляют данные в двоичном виде вроде как не вписываются
    в концепцию, потому что они должны отправлять данные в текстовом, но
    файлы, допустим картинки, они двоичные. И здесь как раз скрывается одна
    из прелестей протокола HTTP. Данный протокол позволяет пересылать по верх
    себя не только текстовую информацию, но и двоичную. Просто для этого мы
    указываем определенный Content-Type.

    В случае, когда мы отправляем серверу не только текст, но и файлы, мы
    указываем Content-Type: multipart/form-data; и указываем границу
    boundary="Asrf4568Ge4h" - данная пара ключь/значение описывает, что
    для данного Content-Type у нас будет несколько элементов, каждый из
    элементов будет разграничен каким то ключом. Asrf4568Ge4h - эта строка
    (рандомная) как раз разделяет те элементы, которые будут отправлятся
    серверу.

    --Asrf4568Ge4h
    Content-Desposition: form-data; name="DestAddress"
    (пустая строка)
    brutal-vasya@example.com
    --Asrf4568Ge4h
    Content-Desposition: form-data; name="MessageTitle"
    (пустая строка)
    Я негодую
    --Asrf4568Ge4h
    Content-Desposition: form-data; name="MessageText"
    (пустая строка)
    Привет. Василий! Твой ручной лев, которого ты оставил у меня на прошлой
    неделе, разодрал весь мой диван. Пожалуйста, забери его скорее!
    Во вложении две фотки с последствиями.
    --Asrf4568Ge4h
    Content-Desposition: form-data; name=AttachedFile1"; filename="horror-photo-1.jpg".git
    Content-Type: image/jpg
    (пустая строка)
    (Двоичное содержимое первой фотографии)
    --Asrf4568Ge4h
    Content-Desposition: form-data; name=AttachedFile1"; filename="horror-photo-2.jpg".git
    Content-Type: image/jpg
    (пустая строка)
    (Двоичное содержимое второй фотографии)
    --Asrf4568Ge4h--
    (отсутствующий эпилог)

    Для image/jpg у нас указан отдельный Content-Type
    Сервер уже сам, когда разбирает это тело, понимает, какой из этих аргументов,
    как передавать в исполняющий код.
"""
